/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package latte;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Scanner;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.VarInsnNode;

import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.Frame;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.MissingOptionException;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;

public class App {
    public static void main(String[] args) throws Exception {
        Options options = new Options();
        Option includeOption = new Option("i", "include", true, "list of classes to modify (default: all)");
        includeOption.setArgs(Option.UNLIMITED_VALUES);

        options.addOption("h", "help", false, "");
        options.addOption("f", "force", false, "do not prompt before overwriting an existing output file");
        options.addOption("o", "output", true, "output file");
        options.addOption("j", "is-jar", false, "whether the input file is a JAR");
        options.addOption("c", "class-path", true,
            String.format("A %c separated list of directories, JAR archives,", File.pathSeparatorChar) +
            "and ZIP archives to search for class files.");
        options.addOption(includeOption);

        HelpFormatter formatter = new HelpFormatter();

        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(options, args);

        if (cmd.hasOption("h")) {
            formatter.printHelp("latte INPUT_CLASS_OR_JAR", "Rebuild the local variable tables in a class file", options, "", true);
            return;
        }

        List<String> cliArgs = cmd.getArgList();
        if (cliArgs.size() != 1) {
            throw new MissingOptionException("a single input file argument is required");
        }

        Path inputFilePath = Paths.get(cliArgs.get(0));
        Path outputFilePath;
        if (cmd.hasOption("o")) {
            outputFilePath = Paths.get(cmd.getOptionValue("o"));
        }
        else {
            outputFilePath = inputFilePath;
        }

        CustomClassLoader classLoader;
        TypeVerifier tf = new TypeVerifier();
        if (cmd.hasOption("j")) {
            if (outputFilePath.toFile().exists() && !cmd.hasOption("f")) {
                Scanner scanner = new Scanner(System.in);
                System.err.println(String.format("Overwrite the existing file %s? (Y/n)", outputFilePath.toString()));
                if (!scanner.hasNext("Y")) {
                    scanner.close();
                    return;
                }
                scanner.close();
            }
            System.out.println(String.format("Overwriting existing file %s", outputFilePath.toString()));
            
            if (outputFilePath != inputFilePath) {
                Files.copy(inputFilePath, outputFilePath, StandardCopyOption.REPLACE_EXISTING);
            }

            FileSystem fs = FileSystems.newFileSystem(outputFilePath);
            classLoader = new CustomClassLoader(inputFilePath.toUri().toURL());
            if (cmd.hasOption("c")) {
                classLoader.setAdditionalClassPath(cmd.getOptionValue("c"));
            }
            tf.setClassLoader(classLoader);
            ZipFile zf = new ZipFile(inputFilePath.toFile());

            List<String> classWhitelist = null;
            if (cmd.hasOption(includeOption)) {
                classWhitelist = Arrays.asList(cmd.getOptionValues(includeOption));
            }
            for (Enumeration<? extends ZipEntry> entries = zf.entries(); entries.hasMoreElements();) {
                ZipEntry entry = entries.nextElement();
                if (!entry.getName().endsWith(".class")) {
                    continue;
                }
                if (classWhitelist != null && !classWhitelist.contains(entry.getName().replace(".class", "").replace('/', '.'))) {
                    continue;
                }
                Path archiveMember = fs.getPath(entry.getName());
                handleClass(archiveMember, archiveMember, true, tf);
            }
            fs.close();
        }
        else {
            classLoader = new CustomClassLoader(inputFilePath);
            if (cmd.hasOption("c")) {
                classLoader.setAdditionalClassPath(cmd.getOptionValue("c"));
            }
            tf.setClassLoader(classLoader);
            handleClass(inputFilePath, outputFilePath, cmd.hasOption("f"), tf);
        }
    }

    public static void handleClass(Path input, Path output, boolean forceOverwrite, TypeVerifier typeVerifier) throws Exception {
        InputStream fi = Files.newInputStream(input);
        ClassReader cr = new ClassReader(fi);

        ClassNode cn = new ClassNode();
        
        cr.accept(cn, ClassReader.EXPAND_FRAMES);

        System.out.println(String.format("Examining class %s", cn.name));
        for (MethodNode methodNode : cn.methods) {
            Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(new ObjectTypeInterpreter());
            try {
                analyzer.analyze(cn.name, methodNode);
            }
            catch (AnalyzerException e) {
                System.err.println(String.format("\tFailed to examine method %s.%s: %s", cn.name, methodNode.name, e.toString()));
                continue;
            }

            System.out.println(String.format("\tExamining method %s", methodNode.name));
            Frame<BasicValue>[] frames = analyzer.getFrames();
            AbstractInsnNode[] instructions=  methodNode.instructions.toArray();

            if (methodNode.localVariables == null) {
                methodNode.localVariables = new ArrayList<LocalVariableNode>();
            }
            else if (methodNode.localVariables.size() > 0) {
                System.err.println(String.format("\tMethod %s already contains local variables, skipping...", methodNode.name));
                continue;
            }
            Type methodType = Type.getType(methodNode.desc);
            boolean isMethodStatic = (methodNode.access & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC;
            LabelNode last = null;
            List<Type> stackFrameLocals = new ArrayList<Type>();
            if (!isMethodStatic || methodType.getArgumentTypes().length != 0) {
                LabelNode first = new LabelNode();
                last = new LabelNode();

                methodNode.instructions.insert(first);
                methodNode.instructions.add(last);

                int index = 0;
                if (!isMethodStatic) {
                    Type thisType = Type.getObjectType(cn.name);
                    stackFrameLocals.add(thisType);
                    LocalVariableNode thisVar = new LocalVariableNode("this", thisType.toString(), null, first, last, index);
                    methodNode.localVariables.add(thisVar);
                    index++;
                }
                Type[] argTypes = methodType.getArgumentTypes();
                for (int i = 0; i < argTypes.length; i++) {
                    Type argType = argTypes[i];
                    stackFrameLocals.add(argType);
                    LocalVariableNode argVar = new LocalVariableNode(String.format("arg%d", i+1), argType.getDescriptor(), null, first, last, index);
                    methodNode.localVariables.add(argVar);
                    index += argType.getSize();
                }
            }

            int localVarNum = 1;
            for (int i = 0; i < instructions.length; i++) {
                Frame<BasicValue> frame = frames[i];
                
                if (instructions[i].getType() == AbstractInsnNode.VAR_INSN) {
                    int opcode = instructions[i].getOpcode();
                    if (
                        opcode == Opcodes.ASTORE ||
                        opcode == Opcodes.ISTORE ||
                        opcode == Opcodes.DSTORE ||
                        opcode == Opcodes.FSTORE ||
                        opcode == Opcodes.LSTORE
                    ) {
                        VarInsnNode insn = (VarInsnNode)instructions[i];
                        BasicValue newValue = frame.getStack(frame.getStackSize() - 1);
                    
                        if (last == null) {
                            last = new LabelNode();
                            methodNode.instructions.add(last);
                        }


                        AbstractInsnNode next = insn.getNext();
                        LabelNode varStart;
                        if (next.getType() == AbstractInsnNode.LABEL) {
                            varStart = (LabelNode)next;
                        }
                        else {
                            varStart = new LabelNode();
                        }
                        boolean exists = false;

                        for (LocalVariableNode var : methodNode.localVariables) {
                            if (var.index == insn.var && var.end == last) {
                                if (!typeVerifier.isAssignableFrom(var.desc, newValue)) {
                                    var.end = varStart;
                                }
                                else {
                                    exists = true;
                                }
                                break;
                            }
                        }
                        if (exists) {
                            continue;
                        }
                        
                        if (!varStart.equals(next)) {
                            methodNode.instructions.insert(insn, varStart);
                        }
    
                        LocalVariableNode localVar = new LocalVariableNode("local"+localVarNum++, newValue.getType().getDescriptor(), null, varStart, last, insn.var);
                        methodNode.localVariables.add(localVar);
                    }
                }
                else if (instructions[i].getType() == AbstractInsnNode.LABEL) {
                    for (LocalVariableNode localVar : methodNode.localVariables) {
                        if (localVar.end == last &&
                            (localVar.index >= frame.getLocals() ||
                             frame.getLocal(localVar.index).getType() == null)
                            ) {
                            localVar.end = (LabelNode)instructions[i];
                        }
                    }
                }
                else if (instructions[i].getType() == AbstractInsnNode.FRAME) {
                    FrameNode fn = ((FrameNode)instructions[i]);
                    for (LocalVariableNode localVar : methodNode.localVariables) {
                        if (localVar.end == last && 
                            localVar.desc.equals(ObjectTypeInterpreter.NULL_TYPE.getDescriptor()))
                        {
                            int stackMapLocalIndex = localVar.index;
                            for (int j = 0; j < fn.local.size(); j++) {
                                Object stackMapLocal = fn.local.get(j);
                                if (j == stackMapLocalIndex) {
                                    /*
                                     * Since this local var is null, it should be safe
                                     * to assume that this is always an object (not a primitive)
                                     */
                                    localVar.desc = Type.getObjectType((String)stackMapLocal).getDescriptor();
                                    break;
                                }
                                if (stackMapLocal instanceof Integer) {
                                    if (stackMapLocal == Opcodes.LONG || stackMapLocal == Opcodes.DOUBLE) {
                                        /*
                                         * This is necessary to account for the fact that long and double
                                         * vars occupy 2 slots in the local variables table, but only one
                                         * in the stack map frame locals.
                                         * https://asm.ow2.io/javadoc/org/objectweb/asm/tree/FrameNode.html#%3Cinit%3E(int,int,java.lang.Object%5B%5D,int,java.lang.Object%5B%5D)
                                         */
                                        stackMapLocalIndex--;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // No need to recompute max or frames
        // because we aren't actually changing
        // the methods
        ClassWriter classWriter = new ClassWriter(0);
        cn.accept(classWriter);
 
        if (!forceOverwrite && output.toFile().exists()) {
            Scanner scanner = new Scanner(System.in);
            System.err.println(String.format("Overwrite the existing file %s? (Y/n)", output.toString()));
            if (!scanner.hasNext("Y")) {
                scanner.close();
                return;
            }
            System.out.println(String.format("Overwriting existing file %s", output.toString()));
            scanner.close();

        }

        OutputStream dout = Files.newOutputStream(output);
        dout.write(classWriter.toByteArray());
        dout.flush();
        dout.close();
    }
}
